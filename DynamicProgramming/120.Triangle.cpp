/**
 *   给定一个三角形 triangle ，找出自顶向下的最小路径和。
 *   每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 
 *   相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，
 *   那么下一步可以移动到下一行的下标 i 或 i + 1 。
 * 
 * 
 * ------------------------------------------------------------
 *       输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
 *       输出：11
 *       解释：如下面简图所示：
 *          2
 *          3 4
 *          6 5 7
 *          4 1 8 3
 *      自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
 *------------------------------------------------------------
 * 
 * 
 * 
 * 
 * 
 */
#include<vector>
#include<iostream>
using namespace std;

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {

        //很经典的dp题目
        int col = triangle.size();   //多少行

        vector<int> dp(col+1,0);    //根据多少行，我们来确定需要多大的辅助空间  这里将里面的元素都初始化为0

        for (int i = col - 1; i >= 0; i--)  //从最后一行开始向第一行走  即从下到上
        {
            for (int j = 0; j <triangle[i].size(); j++)    //从第一列向最后一列走， 从左到右
            {
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]; //先再选择最小的元素 然后再加上要计算的元素
            }
        }
        return dp[0];
    }
};